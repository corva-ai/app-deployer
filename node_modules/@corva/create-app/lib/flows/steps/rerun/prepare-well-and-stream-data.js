import chalk from 'chalk';
import inquirer from 'inquirer';

import { logger } from '../../../helpers/logger.js';

export const PREPARE_WELL_AND_STREAM_TASK_STEP = {
  message: 'Prepare well and stream data...',
  /**
   *
   * @param {object} context
   */
  fn: async (context) => {
    let { assets } = context;
    const { api, manifest } = context;

    const { mappedAssetsToWells, mappedAssetsToStreams, assetsToDelete } = await prepareWellAndStreamData(
      assets,
      api,
      manifest,
    );

    if (assetsToDelete.length) {
      // remove asset ID if could not found stream or well
      assets = assets.filter((assetId) => !assetsToDelete.includes(assetId));
    }

    return {
      ...context,
      assets,
      mappedAssetsToStreams,
      mappedAssetsToWells,
    };
  },
};

/**
 *  CLI prompt question - Please choose the stream
 *
 * @param {object[]} streams
 *
 * @returns {Promise<object>}
 */
const getStreamWithPrompt = async (streams) => {
  const choices = streams.map((stream) => {
    return {
      value: stream,
      name: stream.name,
    };
  });

  if (!choices.length) {
    throw new Error('No completed streams');
  }

  if (choices.length === 1) {
    const [stream] = choices;

    logger.write(`\n\n${chalk.black.underline.bold(`Process stream - ${chalk.green(stream.name)}`)}`);

    return stream.value;
  }

  logger.log('\n');

  return inquirer
    .prompt([
      {
        message: 'Please choose stream?',
        name: 'option',
        type: 'list',
        choices,
      },
    ])
    .then((answers) => answers.option);
};

/**
 *  CLI prompt question - Please choose the well
 *
 * @param {object[]} wells
 * @param {import('../lib/api').Api} api
 *
 * @returns {Promise<object>}
 */
const getWellWithPrompt = async (wells, api) => {
  const choices = await Promise.all(
    wells.map(async (well) => {
      const assetDetails = await api.getAssetById(well.data.attributes.asset_id);

      well.data.name = assetDetails.attributes.name;

      return {
        value: well.data,
        name: well.data.name,
      };
    }),
  );

  if (!choices.length) {
    throw new Error('No wells found');
  }

  if (choices.length === 1) {
    const [well] = choices;

    logger.write(`\n\n${chalk.black.underline.bold(`Process well - ${chalk.green(well.name)}`)}`);
    return well.value;
  }

  logger.log('\n');

  return inquirer
    .prompt([
      {
        message: 'Please choose the well?',
        name: 'option',
        type: 'list',
        choices,
      },
    ])
    .then((answers) => answers.option);
};

/**
 *  Get stream and well data for assets
 *
 * @param {string[]} assets
 * @param {import('../lib/api').Api} api
 * @param {object} manifest
 *
 * @returns {Promise<object>}
 */
const prepareWellAndStreamData = async (assets, api, manifest) => {
  const mappedAssetsToWells = new Map();
  const mappedAssetsToStreams = new Map();
  const assetsToDelete = [];

  for (const assetId of assets) {
    try {
      logger.write(`\n\n${chalk.black.underline.bold(`Process asset ID - ${chalk.green(assetId)}`)}`);

      logger.write('\n    Loading wells...');

      const wells = await api.getWellByAssetId(assetId);
      const well = await getWellWithPrompt(wells, api);
      mappedAssetsToWells.set(well.attributes.asset_id, well);

      logger.write('\n    Loading streams...');

      const streams = await api.getStreamsByAssetIds([assetId], manifest.manifest.application.segments);

      if (!streams || !streams.length) {
        throw new Error(`Could not found streams for asset ID - ${assetId}`);
      }

      const stream = await getStreamWithPrompt(streams);

      mappedAssetsToStreams.set(stream.asset_id, stream);
    } catch (e) {
      logger.write(
        `\n\n${chalk.red.underline.bold(`Skipped the asset ID - ${assetId}, an error occurred: ${e.message}`)}`,
      );

      assetsToDelete.push(assetId);

      if (mappedAssetsToWells.has(assetId)) mappedAssetsToWells.delete(assetId);
      if (mappedAssetsToStreams.has(assetId)) mappedAssetsToStreams.delete(assetId);
    }
  }

  return {
    mappedAssetsToWells,
    mappedAssetsToStreams,
    assetsToDelete,
  };
};
