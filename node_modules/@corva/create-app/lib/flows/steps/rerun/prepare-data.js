import chalk from 'chalk';
import inquirer from 'inquirer';
import _ from 'lodash';
import { logger } from '../../../helpers/logger.js';
import { StepError } from '../../lib/step-error.js';

const MAX_ASSET_IDS_COUNT = 300;

export const PREPARE_DATA_TASK_STEP = {
  message: 'Preparing and checking data...',
  fn: async (context) => {
    const { manifest, options, api } = context;
    let { assets, interval, companyId } = options;

    if (companyId) {
      assets = await getAssetsByCompanyId(companyId, api);
    }

    assets = _.uniq(assets);

    if (assets.length > MAX_ASSET_IDS_COUNT) {
      throw new StepError(`Please no more than ${MAX_ASSET_IDS_COUNT} asset ids!`);
    }

    if (!['scheduler', 'stream'].includes(manifest.manifest.application.type)) {
      throw new StepError('Rerun command supports only "scheduler" or "stream" apps');
    }

    if (!(await promptAreYouSure())) {
      throw new StepError('Command stopped');
    }

    const app = await api.getAppByKey(manifest.manifest.application.key.toLowerCase());
    const appDatasets = await api.getAppDatasetsOperationWrite(app.id);
    const appDatasetsNames = appDatasets.map((dataset) => dataset.attributes.dataset_name);

    const existingAppRuns = await getExistAppRuns(app.id, assets, appDatasetsNames, api);

    if (existingAppRuns.size) {
      for (const appRunAssetId of existingAppRuns.keys()) {
        // remove asset ID if similar rerun already exists
        assets = assets.filter((assetId) => appRunAssetId !== assetId);

        const run = existingAppRuns.get(appRunAssetId);

        logger.write(
          `\n\n${chalk.yellow.bold(
            `A similar rerun with ID ${run.id}, for asset ID ${appRunAssetId} - already exists. Will be skipped!`,
          )}`,
        );
      }
    }

    return {
      assets,
      app,
      options,
      manifest,
      appDatasetsNames,
      interval: getInterval(manifest.manifest, interval),
    };
  },
};

/**
 *  CLI prompt question - Are you sure you want to do this?
 *
 * @returns
 */
const promptAreYouSure = async () => {
  logger.log('\n');
  const answers = await inquirer.prompt([
    {
      message:
        'This command will create an additional load on the server, which may take a long time. \n Are you sure you want to do this?',
      name: 'option',
      type: 'list',
      choices: [
        { value: true, name: 'Yes' },
        { value: false, name: 'No' },
      ],
      default: false,
    },
  ]);
  return answers.option;
};

/**
 *  Get all suitable assets for rerun by company ID
 *
 * @param {number} comanyId
 * @param {object} api
 *
 * @returns {number[]}
 */
const getAssetsByCompanyId = async (companyId, api) => {
  logger.write('\n    Try to find all suitable assets by Company ID...');

  const assets = await api.getAllAssets(['complete', 'idle', 'paused', 'unknown'], companyId);

  logger.write(`\n\n Found ${chalk.yellow.bold(assets.length)} assets, for the company ID ${companyId}!`);

  return assets.map((asset) => asset.id);
};

/**
 *  Check if current runs already exist
 *
 * @param {string} appId
 * @param {string[]} assets
 * @param {string[]} appDatasetsNames
 * @param {object} api
 *
 * @returns {map}
 */
const getExistAppRuns = async (appId, assets, appDatasetsNames, api) => {
  const appRuns = new Map();
  const existingAppRuns = await api.getAppRuns(appId);

  // go through all assets ids
  for (const assetId of assets) {
    const runsForCurrentAsset = existingAppRuns.filter((run) => run.attributes.well_asset_id === assetId);

    // go through all existing runs for current asset ID
    for (const run of runsForCurrentAsset) {
      const currentAppDatasetsNames = run.attributes.app_run_datasets.map((dataset) => dataset.name);

      // if datasets names matched for the same asset ID - then run already exist
      if (appDatasetsNames.sort().toString() === currentAppDatasetsNames.sort().toString()) {
        appRuns.set(assetId, run);
      }
    }
  }

  return appRuns;
};

/**
 *  Get interval
 *
 * @param {object} manifest
 * @param {number} intervalOption
 *
 * @returns {number | null}
 */
const getInterval = (manifest, intervalOption) => {
  if (manifest.application.type !== 'scheduler') {
    return null;
  }

  const DEFAULT_INTERVAL = 3600;
  const interval = intervalOption || DEFAULT_INTERVAL;

  logger.write(`\n\n${chalk.black.underline.bold(`Use interval - ${chalk.green(interval)}`)}`);

  return parseInt(interval);
};
