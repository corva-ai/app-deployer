import chalk from 'chalk';
import Glob from 'glob';
import isGlob from 'is-glob';
import _ from 'lodash/fp.js';
import { promises as fs } from 'node:fs';
import { resolve } from 'node:path';
import { promisify } from 'node:util';
import { getIncreasedVersion } from '../../scripts/utils/version.js';
import { loadJson } from '../lib/json.js';
import { StepError } from '../lib/step-error.js';

const glob = promisify(Glob);

import debugFn from 'debug';

const debug = debugFn('cca:flow:zip:resolve');

const uniqueValues = (array) => Array.from(new Set(array));

export const FILE_LIST_RESOLVE_STEP = {
  message: 'Resolving files list...',
  fn: async (context) => {
    const { patterns, manifest, dirName, options } = context;
    const files = await transformPatternsIntoFileNames(dirName, patterns, options.ignoredFiles);

    if (manifest.isUi()) {
      return resolveDataToZipUiApp(files, context);
    }

    if (manifest.isNode()) {
      return resolveDataForZipNodeJsApp(files, context);
    }

    if (manifest.isPython()) {
      return resolveDataForZipPythonApp(files, context);
    }

    throw new Error(`Unsupported runtime: ${manifest.runtime}`);
  },
};

const transformPatternsIntoFileNames = async (dirName, patterns, ignoredFiles = []) => {
  const filesFromPatterns = [];

  for (const pattern of patterns) {
    if (pattern.includes('node_modules')) {
      debug('Invalid file pattern', pattern);

      continue;
    }

    if (!isGlob(pattern, { strict: false })) {
      filesFromPatterns.push(pattern);

      continue;
    }

    const files = await glob(pattern, {
      cwd: dirName,
      ignore: ['**/node_modules', ...ignoredFiles],
      nodir: true,
    });

    filesFromPatterns.push(...files);
  }

  return filesFromPatterns;
};

/**
 *
 * @param {string[]} itemsToZip
 * @param {object} param1
 * @param {import('../lib/manifest').Manifest} param1.manifest
 * @returns
 */
const resolveDataToZipUiApp = async (itemsToZip = [], { options, pkg, dirName, manifest }) => {
  const version = await getIncreasedVersion(pkg.version, options);
  const zipFileName = `${manifest.unix_name}-${version}.zip`;
  const itemsToSave = [];
  const shouldUpdateVersion = version !== pkg.version;

  if (shouldUpdateVersion) {
    pkg.version = version;

    itemsToSave.push({
      name: 'package.json',
      content: pkg,
      message: chalk(
        `\n${chalk.yellow`NOTE`}: Version of your app was updated to ${version} (package.json), please don't lower it.`,
      ),
    });
  }

  itemsToSave.push({
    name: 'packageForSource.json',
    content: _.set(
      'scripts',
      {
        build: 'webpack --config=./config-overrides.js --mode production',
      },
      pkg,
    ),
  });

  const itemsToRemove = ['packageForSource.json'];

  itemsToZip.push(
    'manifest.json',
    'config-overrides.js',
    'tsconfig.json',
    '.npmrc',
    '.nvmrc',
    'yarn.lock',
    {
      path: resolve(dirName, 'packageForSource.json'),
      name: 'package.json',
    },
    ...(await transformPatternsIntoFileNames(dirName, ['src/**/*'], options.ignoredFiles)),
  );

  return {
    zipFileName,
    itemsToZip,
    itemsToSave,
    itemsToRemove,
  };
};

/**
 *
 * @param {string[]} itemsToZip
 * @param {object} param1
 * @param {import('../lib/manifest').Manifest} param1.manifest
 * @returns
 */
const resolveDataForZipNodeJsApp = async (itemsToZip = [], { options, pkg, dirName, manifest }) => {
  const version = await getIncreasedVersion(pkg.version, options);
  const zipFileName = `${manifest.unix_name}-${version}.zip`;
  const itemsToSave = [];
  const shouldUpdateVersion = version !== pkg.version;

  if (shouldUpdateVersion) {
    pkg.version = version;

    itemsToSave.push({
      name: 'package.json',
      content: pkg,
      message: chalk(
        `\n${chalk.yellow`NOTE`}: Version of your app was updated to ${version} (package.json), please don't lower it.`,
      ),
    });
  }

  const packageDirContent = await fs.readdir(dirName);
  const shouldPushDefaultSrc = !itemsToZip.length;

  itemsToZip.push('config', 'manifest.json', 'package.json', '.nvmrc', '.npmrc', '.eslintrc.js');

  if (packageDirContent.includes('package-lock.json')) {
    itemsToZip.push('package-lock.json');

    if (shouldUpdateVersion) {
      itemsToSave.push({
        name: 'package-lock.json',
        content: _.set('version', version, await loadJson(dirName, 'package-lock.json')),
      });
    }
  } else if (packageDirContent.includes('yarn.lock')) {
    itemsToZip.push('yarn.lock');
  } else {
    throw new StepError(`No lock file found in ${dirName}`);
  }

  if (packageDirContent.includes('tsconfig.json')) {
    itemsToZip.push('tsconfig.json', 'tsconfig.build.json');

    if (shouldPushDefaultSrc) {
      itemsToZip.push(
        'index.ts',
        ...(await glob('+(src|lib)/**/*.ts', {
          cwd: dirName,
          ignore: options.ignoredFiles,
        })),
      );
    }
  } else if (shouldPushDefaultSrc) {
    itemsToZip.push(
      'index.js',
      ...(await glob('+(src|lib)/**/*.js', {
        cwd: dirName,
        ignore: options.ignoredFiles,
      })),
    );
  }

  return {
    zipFileName,
    itemsToZip: uniqueValues(itemsToZip),
    itemsToSave,
    itemsToRemove: [],
  };
};

/**
 *
 * @param {string[]} itemsToZip
 * @param {object} param1
 * @param {import('../lib/manifest').Manifest} param1.manifest
 * @returns
 */
const resolveDataForZipPythonApp = async (itemsToZip = [], { manifest, dirName, options }) => {
  const zipFileName = `${manifest.unix_name}.zip`;

  if (!itemsToZip.length) {
    itemsToZip.push(
      ...(await glob('**/*.py', {
        cwd: dirName,
        ignore: [...(options.ignoredFiles || []), 'venv/**/*'],
      })),
    );
  }

  itemsToZip.push('manifest.json', 'requirements.txt');

  return {
    zipFileName,
    itemsToZip: uniqueValues(itemsToZip),
    itemsToSave: [],
    itemsToRemove: [],
  };
};
