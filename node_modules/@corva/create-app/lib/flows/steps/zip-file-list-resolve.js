const { set } = require('lodash/fp');
const { resolve } = require('path');
const { promises: fs } = require('fs');
const Glob = require('glob');
const chalk = require('chalk');
const isGlob = require('is-glob');
const { promisify } = require('util');
const { getIncreasedVersion } = require('../../scripts/utils/version');
const { loadJson } = require('../lib/json');
const { StepError } = require('../lib/step-error');

const glob = promisify(Glob);
const debug = require('debug')('cca:flow:zip:resolve');

const uniqueValues = (array) => Array.from(new Set(array));

const FILE_LIST_RESOLVE_STEP = {
  message: 'Resolving files list...',
  fn: async (context) => {
    const { patterns, manifest, dirName, options } = context;
    const files = await transformPatternsIntoFileNames(dirName, patterns, options.ignoredFiles);

    if (manifest.isUi()) {
      return resolveDataToZipUiApp(files, context);
    }

    if (manifest.isNode()) {
      return resolveDataForZipNodeJsApp(files, context);
    }

    if (manifest.isPython()) {
      return resolveDataForZipPythonApp(files, context);
    }

    throw new Error(`Unsupported runtime: ${manifest.runtime}`);
  },
};

const transformPatternsIntoFileNames = async (dirName, patterns, ignoredFiles = []) => {
  const filesFromPatterns = [];

  for (const pattern of patterns) {
    if (pattern.includes('node_modules')) {
      debug('Invalid file pattern', pattern);

      continue;
    }

    if (!isGlob(pattern, { strict: false })) {
      filesFromPatterns.push(pattern);

      continue;
    }

    const files = await glob(pattern, {
      cwd: dirName,
      ignore: ['**/node_modules', ...ignoredFiles],
      nodir: true,
    });

    filesFromPatterns.push(...files);
  }

  return filesFromPatterns;
};

const resolveDataToZipUiApp = async (itemsToZip = [], { options, pkg, dirName }) => {
  const version = await getIncreasedVersion(pkg.version, options);
  const zipFileName = `${pkg.name}-${version}.zip`;
  const itemsToSave = [];
  const shouldUpdateVersion = version !== pkg.version;

  if (shouldUpdateVersion) {
    pkg.version = version;

    itemsToSave.push({
      name: 'package.json',
      content: pkg,
      message: chalk(
        `\n${chalk.yellow`NOTE`}: Version of your app was updated to ${version} (package.json), please don't lower it.`
      ),
    });
  }

  itemsToSave.push({
    name: 'packageForSource.json',
    content: set(
      'scripts',
      {
        build: 'webpack --config=./config-overrides.js --mode production',
      },
      pkg
    ),
  });

  const itemsToRemove = ['packageForSource.json'];

  itemsToZip.push(
    'manifest.json',
    'config-overrides.js',
    'tsconfig.json',
    '.npmrc',
    '.nvmrc',
    'yarn.lock',
    { path: resolve(dirName, 'packageForSource.json'), name: 'package.json' },
    ...(await transformPatternsIntoFileNames(dirName, ['src/**/*'], options.ignoredFiles))
  );

  return {
    zipFileName,
    itemsToZip,
    itemsToSave,
    itemsToRemove,
  };
};

const resolveDataForZipNodeJsApp = async (itemsToZip = [], { options, pkg, dirName }) => {
  const version = await getIncreasedVersion(pkg.version, options);
  const zipFileName = `${pkg.name}-${version}.zip`;
  const itemsToSave = [];
  const shouldUpdateVersion = version !== pkg.version;

  if (shouldUpdateVersion) {
    pkg.version = version;

    itemsToSave.push({
      name: 'package.json',
      content: pkg,
      message: chalk(
        `\n${chalk.yellow`NOTE`}: Version of your app was updated to ${version} (package.json), please don't lower it.`
      ),
    });
  }

  const packageDirContent = await fs.readdir(dirName);
  const shouldPushDefaultSrc = !itemsToZip.length;

  itemsToZip.push('config', 'manifest.json', 'package.json');

  if (packageDirContent.includes('package-lock.json')) {
    itemsToZip.push('package-lock.json');

    if (shouldUpdateVersion) {
      itemsToSave.push({
        name: 'package-lock.json',
        content: set('version', version, await loadJson(dirName, 'package-lock.json')),
      });
    }
  } else if (packageDirContent.includes('yarn.lock')) {
    itemsToZip.push('yarn.lock');
  } else {
    throw new StepError(`No lock file found in ${dirName}`);
  }

  if (packageDirContent.includes('tsconfig.json')) {
    itemsToZip.push('tsconfig.json', 'tsconfig.build.json');

    if (shouldPushDefaultSrc) {
      itemsToZip.push(
        'index.ts',
        ...(await glob('+(src|lib)/**/*.ts', { cwd: dirName, ignore: options.ignoredFiles }))
      );
    }
  } else if (shouldPushDefaultSrc) {
    itemsToZip.push(
      'index.js',
      ...(await glob('+(src|lib)/**/*.js', { cwd: dirName, ignore: options.ignoredFiles }))
    );
  }

  return {
    zipFileName,
    itemsToZip: uniqueValues(itemsToZip),
    itemsToSave,
    itemsToRemove: [],
  };
};

const resolveDataForZipPythonApp = async (itemsToZip = [], { manifest, dirName, options }) => {
  const zipFileName = `${manifest.manifest.application.name}.zip`;

  if (!itemsToZip.length) {
    itemsToZip.push(...(await glob('**/*.py', { cwd: dirName, ignore: [...(options.ignoredFiles || []), 'venv/**/*'] })));
  }

  itemsToZip.push('manifest.json', 'requirements.txt');

  return {
    zipFileName,
    itemsToZip: uniqueValues(itemsToZip),
    itemsToSave: [],
    itemsToRemove: [],
  };
};

module.exports = { FILE_LIST_RESOLVE_STEP };
