import debugFn from 'debug';
import got from 'got';
import { StepError } from './step-error.js';

const debug = debugFn('cca:api');

/**
 * Connect to Corva API
 *
 */
export class Api {
  /**
   * @type {import('got').Got}
   */
  #api;

  constructor(envName, apiKey, authToken = null) {
    const prefixUrl = `https://api${envName === 'production' ? '' : `.${envName}`}.corva.ai`;

    this.#api = got.extend({
      prefixUrl,
      retry: { limit: 0 },
      headers: {
        'Authorization': authToken ? `Bearer ${authToken}` : `API ${apiKey}`,
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      hooks: {
        beforeRequest: [debug],
      },
    });
  }

  /**
   * Get app by appKey
   *
   * @public
   *
   * @param {string} appKey
   *
   * @returns  {object}
   */
  async getAppByKey(appKey) {
    const { data } = await this.#api
      .get('v2/apps', {
        searchParams: { per_page: 2, search: appKey },
      })
      .json();

    const app = data.find((app) => app.attributes.app_key === appKey);
    if (!app) {
      throw new Error(`App with key - ${appKey}, not exist`);
    }

    return app;
  }

  /**
   * Get app datasets
   *
   * @public
   *
   * @param {string} appId
   *
   * @returns  {object}
   */
  async getAppDatasetsOperationWrite(appId) {
    const { data } = await this.#api
      .get(`v2/apps/${appId}/app_datasets?dataset_operation=write&fields[]=app_dataset.dataset_name`)
      .json();

    return data;
  }

  /**
   * Get asset details
   *
   * @public
   *
   * @param {string} assetId
   *
   * @returns  {Promise<object[]>}
   */
  async getAssetById(assetId) {
    const { data } = await this.#api.get(`v2/assets/${assetId}`).json();

    return data;
  }

  /**
   * Get assets streams by ids
   *
   * @public
   *
   * @param {string[]} assetIds
   * @param {string[]} segments
   * @param {string[]} statuses
   *
   * @returns  {Promise<object[]>}
   */
  async getStreamsByAssetIds(assetIds, segments, statuses = ['complete']) {
    const searchParams = new URLSearchParams([
      ...assetIds.map((assetId) => ['asset_id[]', assetId]),
      ...segments.map((segment) => ['segment[]', segment]),
      ...statuses.map((status) => ['status[]', status]),
    ]);

    return this.#api.get(`v1/app_streams`, { searchParams }).json();
  }

  /**
   * Get all assets
   *
   * @public
   *
   * @param {string[]} statuses
   * @param {number} companyId
   * @param {number} perPage
   *
   * @returns  {Promise<object[]>}
   */
  async getAllAssets(statuses = ['active'], companyId = null, perPage = 2000) {
    const searchParams = [['per_page', perPage]];

    if (companyId) {
      searchParams.push(['company_id', companyId]);
    }

    if (statuses?.length) {
      searchParams.push(...statuses.map((status) => ['status[]', status]));
    }

    const { data } = await this.#api.get(`v2/assets`, { searchParams: new URLSearchParams(searchParams) }).json();

    return data;
  }

  /**
   * Get wells data by asset id
   *
   * @public
   *
   * @param {string} assetId
   *
   * @returns  {object[]}
   */
  async getWellByAssetId(assetId) {
    const { wells } = await this.#api
      .post('v2/assets/resolve', {
        json: { assets: [assetId] },
      })
      .json();

    if (!wells || !wells.length) {
      throw new Error(`Could not found wells by asset ID - ${assetId}`);
    }

    return wells;
  }

  /**
   * Queue app run for create new task
   *
   * @public
   *
   * @param {string} appId
   * @param {string} version
   * @param {number} interval
   * @param {string} wellId
   * @param {string[]} appDatasetsNames
   * @param {string} streamId
   *
   * @returns  {object}
   */
  async queueAppRun(appId, version, interval, wellId, appDatasetsNames, streamId) {
    const json = {
      app_run: {
        app_stream_id: streamId,
        well_id: wellId,
        app_version: version,
        datasets: appDatasetsNames,
        settings: {
          end: 0,
          invokes: null,
          records_per_event: 300,
          start: 0,
        },
      },
    };

    if (interval) {
      json.app_run.settings.interval = interval;
    }

    const { data } = await this.#api.post(`v2/apps/${appId}/app_runs`, { json }).json();

    return data;
  }

  /**
   * Get all active(status - pending or in_progress or running) runs by app ID
   *
   * @public
   *
   * @param {string} appId
   *
   * @returns  {object[]}
   */
  async getAppRuns(appId) {
    const { data } = await this.#api
      .get(`v2/apps/${appId}/app_runs?page=1&per_page=500&status[]=pending&status[]=in_progress&status[]=running`)
      .json();

    return data;
  }

  /**
   * Upload packages
   *
   * @public
   *
   * @param {string} appKey
   * @param {object} formData
   *
   * @returns
   */
  async uploadPackages(appKey, formData) {
    const uploadURL = `v2/apps/${appKey}/packages/upload`;

    try {
      const { data } = await this.#api
        .post(uploadURL, {
          headers: formData.getHeaders(),
          body: formData,
        })
        .json();

      return {
        id: data.id,
        status: data.attributes.status,
      };
    } catch (e) {
      throw new StepError(`${JSON.parse(e.response.body).message || ''} \nPOST: ${uploadURL} failed.`, { cause: e });
    }
  }

  /**
   * @param {string} appId
   * @param {string} id
   * @param {string} notes
   *
   * @returns { Promise<{id: number, status: string}>}
   */
  async addNotes(appId, id, notes) {
    const { data } = await this.#api
      .patch(`v2/apps/${appId}/packages/${id}`, {
        json: { package: { notes } },
      })
      .json();

    return {
      id: data.id,
      status: data.attributes.status,
    };
  }

  /**
   * @param {string} appId
   * @param {string} uploadId
   *
   * @returns { Promise<{id: number, status: string}>}
   */
  async checkApp(appId, uploadId) {
    const { data } = await this.#api.get(`v2/apps/${appId}/packages/${uploadId}`).json();

    return {
      id: data.id,
      status: data.attributes.status,
    };
  }

  /**
   * @param {string} appId
   * @param {string} uploadId
   *
   * @returns { Promise<void>}
   */
  deleteAppUpload(appId, uploadId) {
    return this.#api.delete(`v2/apps/${appId}/packages/${uploadId}`).json();
  }

  /**
   * @param {string} appId
   * @param {string} id
   *
   * @returns { Promise<{id: number, status: string}>}
   */
  async publishApp(appId, id) {
    console.log(`v2/apps/${appId}/packages/${id}`, {
      json: { package: { status: 'published' } },
    });
    const { data } = await this.#api
      .patch(`v2/apps/${appId}/packages/${id}`, {
        json: { package: { status: 'published' } },
      })
      .json();

    console.log('done');

    return {
      id: data.id,
      status: data.attributes.status,
    };
  }

  /**
   * Get app packages
   *
   * @param {string} appId
   *
   * @returns { Promise<object[]>}
   */
  async getAppPackages(appId) {
    const { data } = await this.#api.get(`v2/apps/${appId}/packages`).json();
    return data;
  }

  /**
   * Connect app to the stream
   *
   * @public
   *
   * @param {string} appId
   * @param {string} streamId
   * @param {object} settings
   * @param {string} status
   *
   * @returns  { Promise<object> }
   */
  async connectAppToStream(appId, streamId, settings, status = 'active') {
    const json = {
      app_stream_id: streamId,
      app_id: appId,
      status,
      settings,
      scheduler_type: settings.scheduler_type,
    };

    return this.#api.post('v1/app_connections', { json }).json();
  }

  /**
   * @param {string} appId
   * @param {string} id
   * @param {'BETA' | 'PROD'} label
   *
   * @returns { Promise<{id: number, status: string}>}
   */
  async putLabel(appId, id, label) {
    await this.#api.patch(`v2/apps/${appId}/packages/${id}`, {
      json: { package: { label } },
    });
  }
}
