import archiver from 'archiver';
import debugFn from 'debug';

const debug = debugFn('cca:zip');

import { createWriteStream, promises as fs } from 'node:fs';
import path from 'node:path';

export const createZipArchive = async (dirName, zipName, itemsToZip = []) => {
  const filePath = path.resolve(dirName, zipName);
  const archive = archiver.create('zip', {});
  const output = createWriteStream(filePath);

  // pipe archive data to the file
  archive.pipe(output);

  // eslint-disable-next-line no-async-promise-executor
  await new Promise(async (resolve, reject) => {
    output.once('close', resolve).once('end', function () {
      debug('Data has been drained');
    });

    archive.on('warning', function (err) {
      if (err.code === 'ENOENT') {
        console.warn(err.message);

        return;
      }

      throw err;
    });

    archive.once('error', reject);

    const dataToZip = await getDataToZip(itemsToZip, dirName);

    for (const item of dataToZip) {
      if (item.isDir) {
        debug(`Adding directory %s -> %s`, item.path, item.name);
        archive.directory(item.path, item.name);

        continue;
      }

      debug(`Adding file %s -> %s`, item.path, item.name);
      archive.file(item.path, { name: item.name });
    }

    archive.finalize();
  });

  return archive.pointer();
};

const getDataToZip = async (itemsToZip, dirName) => {
  const promises = itemsToZip.map(async (name) => {
    const nameWasProvided = typeof name === 'string';
    const filePath = nameWasProvided ? path.resolve(dirName, name) : name.path;
    const fileName = nameWasProvided ? name : name.name;

    const { exists, isDir } = await fs
      .lstat(filePath)
      .then((stat) => ({
        exists: true,
        isDir: stat.isDirectory(),
      }))
      .catch(() => {
        debug(`%s location not exist, filtering it out`, filePath);

        return { exists: false, isDir: false };
      });

    return {
      name: fileName,
      path: filePath,
      exists,
      isDir,
    };
  });
  const allData = await Promise.all(promises);

  return allData.filter((f) => f.exists);
};
