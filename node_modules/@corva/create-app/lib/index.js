#!/usr/bin/env node

'use strict';

const chalk = require('chalk');
const figlet = require('figlet');
const { Command, CommanderError, Option } = require('commander');
const fs = require('fs-extra');
const inquirer = require('inquirer');
const os = require('os');
const path = require('path');
const semver = require('semver');

const {
  ensureLatestVersion,
  warnIfOutdated,
  ensureBumpVersion,
} = require('./scripts/utils/version');
const utils = require('./helpers/utils.js');
const manifestHelpers = require('./helpers/manifest.js');
const versioning = require('./helpers/versioning.js');

const { getDefaultsForPackageJson } = require('./constants/package.js');
const manifestConstants = require('./constants/manifest.js');

const packageJson = require('../package.json');
const { clear } = require('console');
const spawn = require('cross-spawn');
const { runFlow } = require('./flow');
const { ERROR_ICON } = require('./constants/messages');
const { StepError } = require('./flows/lib/step-error');
const { RELEASE_FLOW } = require('./flows/release');
const { ZIP_FLOW } = require('./flows/zip');
const { bumpVersionOptionDeprecated, bumpVersionOption } = require('./bump-version.option');
const { Manifest } = require('./flows/lib/manifest');
const { resolveAppRuntime } = require('./helpers/resolve-app-runtime');

const writejsonOptions = {
  spaces: 2,
  EOL: os.EOL,
};

function startingMessage() {
  clear();
  console.log(chalk.green('   Welcome to apps generator for:'));
  console.log(chalk.cyan(figlet.textSync('CORVA.AI', { horizontalLayout: 'full' })));
}

function checkNodeVersion() {
  process.stdout.write('Checking node version...');

  const unsupportedNodeVersion = !semver.satisfies(process.version, '>=16');
  if (unsupportedNodeVersion) {
    console.log(
      chalk.red(
        `\nYou are using Node ${process.version}.\n\n` +
          `Please update to Node 16 or higher for a better, fully supported experience.\n`
      )
    );
    // Fall back to latest supported react-scripts on Node 4
    return process.exit(1);
  }
  process.stdout.write('  ✅  \n');
}

function checkOptions(opts) {
  let isValid = true;
  const values = {};

  manifestConstants.getManifestMandatoryKeys(opts).forEach((key) => {
    if (!opts[key]) {
      isValid = false;
    }

    values[key] = opts[key];
  });

  return {
    isValid,
    values,
  };
}

const printDeprecationNotice = (param) =>
  console.warn(
    chalk.bgYellowBright`DEPRECATED OPTION: ${param}` +
      ` Use ${chalk.cyan(`create-corva-app ${param} .`)} instead`
  );

async function initialChecks() {
  const program = new Command()
    .hook('preAction', async () => {
      checkNodeVersion();

      await warnIfOutdated();
    })
    .configureOutput({ writeErr: () => undefined })
    .exitOverride();

  const createCommand = program
    .command('create', { isDefault: true })
    .description('Create a new app')
    .argument('[project-directory]', 'project directory to work with', process.cwd())
    .usage(`${chalk.green('<project-directory>')} [options]`);

  manifestConstants.manifestOptions().forEach((value) => {
    const type = typeof value.default;
    const option = new Option(
      `${value.alias ? `-${value.alias}, ` : ''}--${value.name} [${
        (type !== 'undefined' && type) || 'string'
      }]`,
      value.message
    );

    if (value.choices) {
      if (typeof value.choices === 'function') {
        option.choices(value.choices());
      } else {
        option.choices(
          value.choices.map((choice) => `${typeof choice === 'object' ? choice.value : choice}`)
        );
      }
    }

    if (type === 'number') {
      option.argParser(Number);
    }

    if (type !== 'undefined') {
      option.default(value.default);
    }

    createCommand.addOption(option);
  });

  createCommand
    .version(packageJson.version)
    .addOption(
      new Option(
        '-z, --zip [string]',
        chalk.bgYellow`DEPRECATED` + ` Use ${chalk.cyan`zip`} command instead`
      )
    )
    .addOption(
      new Option(
        '--release',
        chalk.bgYellow`DEPRECATED` + ` Use ${chalk.cyan`release`} command instead`
      )
    )
    .addOption(bumpVersionOptionDeprecated);

  createCommand.action(async (dirName, options) => {
    if (options.zip || options.release) {
      options.bumpVersion = await ensureBumpVersion(options.bumpVersion);
    }

    if (options.zip) {
      printDeprecationNotice('zip');

      return runFlow(ZIP_FLOW, { dirName, patterns: [], options });
    }

    if (options.release) {
      printDeprecationNotice('release');

      return runFlow(RELEASE_FLOW, { dirName, patterns: [], options });
    }

    startingMessage();

    // NOTE: Default action
    await createApp(dirName, options);
  });

  program
    .command('zip')
    .description('Bundle app')
    .argument('<project-directory>', 'Project directory to work with')
    .argument('[patterns...]', 'Additional patterns to zip', [])
    .addOption(bumpVersionOption)
    .addOption(new Option('--ignored-files [ignoredFiles...]', 'Patterns to skip zip', []))
    .action(async (dirName, patterns, options) => {
      options.bumpVersion = await ensureBumpVersion(options.bumpVersion);

      return runFlow(ZIP_FLOW, { dirName, patterns, options });
    });

  program
    .command('release')
    .description('Release app')
    .argument('<project-directory>', 'Project directory to work with')
    .argument('[patterns...]', 'Additional patterns to zip', [])
    .addOption(bumpVersionOption)
    .addOption(new Option('--ignored-files [ignoredFiles...]', 'Patterns to skip zip', []))
    .action(async (dirName, patterns, options) => {
      options.bumpVersion = await ensureBumpVersion(options.bumpVersion);

      return runFlow(RELEASE_FLOW, { dirName, patterns, options });
    });

  try {
    await program.parseAsync(process.argv);
  } catch (e) {
    handleError(e);

    process.exit(1);
  }
}

const handleError = (e) => {
  if (e instanceof CommanderError) {
    handleCommanderError(e);

    return;
  }

  process.stdout.write(ERROR_ICON);

  if (!(e instanceof StepError)) {
    console.error(chalk.red(e));

    return;
  }

  console.log(chalk.red(e.message));
  e.cause && console.error(chalk.red(e.cause));
};

const handleCommanderError = (e) => {
  switch (e.code) {
    case 'commander.missingArgument': {
      const match = /error:.*'(.*)'/.exec(e.message);

      if (match && match[1] === 'project-directory') {
        const commandName = program.args[0] || program._defaultCommandName;

        console.error('Please specify the project directory:');
        console.log(
          `  ${chalk.cyan(program.name())} ${commandName} ${chalk.green('<project-directory>')}`
        );
        console.log();
        console.log('For example:');
        console.log(
          `  ${chalk.cyan(program.name())} ${commandName} ${chalk.green('my-react-app')}`
        );
        console.log();
        console.log(
          `Run ${chalk.cyan(`${program.name()} help ${commandName}`)} to see all options.`
        );
      } else {
        console.error('❌', e.message);
      }

      break;
    }
    case 'commander.help':
    case 'commander.helpDisplayed': {
      // ignore
      break;
    }
    default: {
      console.error('❌', e.message);
    }
  }
};

async function initPackage(projectName, opts) {
  const manifest = new Manifest(manifestHelpers.fillManifest(opts));
  const runtime = resolveAppRuntime(opts);

  if (manifest.isUi()) {
    await ensureLatestVersion();
  }

  const root = path.resolve(projectName);

  console.log(`Creating a new Corva app in ${chalk.green(root)}.`);

  if (fs.existsSync(root)) {
    throw new Error(`Directory already exists: ${root}`);
  }
  await fs.mkdir(root);
  await fs.writeJSON(path.join(root, 'manifest.json'), manifest.manifest, writejsonOptions);

  await addTemplate(root, manifest, runtime);
  await configureApp(root, manifest, runtime);
  await installApp(root, manifest, runtime);

  console.log();
}

async function createApp(dirName, opts) {
  const { isValid, values } = checkOptions(opts);

  if (isValid) {
    Object.keys(values).forEach((key) => {
      console.log(`${key} : ${values[key]}`);
    });

    return initPackage(dirName, opts);
  }

  console.log('Please fill your app Metadata');

  const answers = await inquirer.prompt(manifestConstants.manifestOptions(dirName), opts);

  return initPackage(dirName, answers);
}

/**
 *
 * @param {string} root
 * @param {import('./flows/lib/manifest').Manifest} manifest
 * @param {*} runtime
 */
async function addTemplate(root, manifest, runtime) {
  console.log(chalk.green('Copying app template...'));
  console.log();

  const templateFolder = path.resolve(
    __dirname,
    '..',
    'templates',
    runtime.language,
    manifest.type
  );

  utils.copyFolderRecursiveSync(templateFolder, root);

  if (manifest.isNode()) {
    utils.copyFolderRecursiveSync(path.resolve(__dirname, '..', 'common', 'node'), root);
  }

  if (manifest.isPython()) {
    utils.copyFolderRecursiveSync(path.resolve(__dirname, '..', 'common', 'python'), root);
  }

  // We can't have .gitignore file in our templates.
  // It's missing when @corva/create-app is installed.
  // That's why we manually rename gitignore to .gitignore after copying template
  fs.renameSync(path.join(root, 'gitignore'), path.join(root, '.gitignore'));

  console.log(chalk.green('Done: copying app template!'));
}

/**
 *
 * @param {string} root
 * @param {import('./flows/lib/manifest').Manifest} manifest
 * @param {*} runtime
 */
async function configureApp(root, manifest, runtime) {
  if (manifest.isJs()) {
    await addPackageJSON(root, manifest, runtime);
  }

  if (manifest.isNode()) {
    await addNvmRc(root, manifest, runtime);
    await addTsConfigs(root, manifest, runtime);
  }

  if (manifest.isPython() && manifest.isScheduler()) {
    patchSchedulerForPython(root, manifest, runtime);
  }
}

const addNvmRc = async (root, manifest, runtime) => {
  await fs.outputFile(path.join(root, '.nvmrc'), `${runtime.version}\n`);
}

const addTsConfigs = (root, manifest, runtime) => {
  if (runtime.language !== 'typescript') {
    return;
  }

  return Promise.all([
    fs.writeJson(
      path.resolve(root, 'tsconfig.json'),
      {
        extends: `@tsconfig/node${runtime.version}/tsconfig.json`,
        compilerOptions: {
          inlineSourceMap: true,
        },
      },
      writejsonOptions
    ),
    fs.writeJson(
      path.resolve(root, 'tsconfig.build.json'),
      {
        extends: './tsconfig.json',
        include: ['lib/**/*.ts', 'index.ts'],
        exclude: ['node_modules', '**/*.spec.ts'],
      },
      writejsonOptions
    ),
  ]);
};

function patchSchedulerForPython(root, manifest, runtime) {
  const schedulerType = manifest.manifest.settings.app.scheduler_type;

  if (schedulerType === manifestConstants.SCHEDULER_TYPE_DATA_TIME.value) {
    return;
  }

  const templateFolder = path.resolve(
    __dirname,
    '..',
    'templates',
    runtime.language,
    manifest.type
  );
  const originalType = 'ScheduledDataTimeEvent';
  const replacementType =
    schedulerType === manifestConstants.SCHEDULER_TYPE_DEPTH.value
      ? 'ScheduledDepthEvent'
      : 'ScheduledNaturalTimeEvent';
  const patchedCode = fs
    .readFileSync(path.join(templateFolder, 'lambda_function.py'), 'utf-8')
    .replace(new RegExp(originalType, 'g'), replacementType);

  fs.writeFileSync(path.join(root, 'lambda_function.py'), patchedCode);
}

/**
 *
 * @param {string} root
 * @param {import('./flows/lib/manifest').Manifest} manifest
 */
function addPackageJSON(root, manifest, runtime) {
  const defaults = getDefaultsForPackageJson(manifest, runtime);

  const packageJson = {
    name: manifest.name.replace(/\W/g, ''),
    version: defaults.version,
    description: manifest.description || defaults.description,
    engines: {
      node: `^${runtime.version}`,
      [runtime.packageManager]: '*',
    },
    scripts: defaults.scripts,
    dependencies: defaults.dependencies,
    devDependencies: defaults.devDependencies,
  };

  return fs.writeJSON(path.join(root, 'package.json'), packageJson, writejsonOptions);
}

/**
 *
 * @param {string} root
 * @param {import('./flows/lib/manifest').Manifest} manifest
 */
async function installApp(root, manifest, runtime) {
  const command = manifest.isJs() ? runtime.packageManager : 'make';
  const args = ['install'];
  const opts = { stdio: ['inherit', 'inherit', 'pipe'], cwd: root }

  console.log(chalk.yellow(`Installing template dependencies using ${runtime.packageManager}...`));
  const proc = manifest.isJs() ?
    spawn.sync(`\\. ~/.nvm/nvm.sh && nvm use && ${command} ${args.join(' ')}`, { shell: true, ...opts }) :
    spawn.sync(command, args, opts);

  if (proc.stderr) {
    const error = proc.stderr
      .toString('utf8')
      .split('\n')
      // NOTE: filter out warnings caused by @corva/ui peer dependencies
      .filter((line) => !line.includes('@corva/ui'))
      .join('\n');
    console.log(error);
  }

  if (proc.status !== 0) {
    console.error(`\`${command} ${args.join(' ')}\` failed`);
    return;
  }

  console.log(chalk.green('Successfull project install'));

  if (versioning.tryGitInit(root)) {
    console.log();
    console.log('Initialized a git repository.');

    if (versioning.tryGitCommit(root)) {
      console.log();
      console.log('Created git commit.');
    }
  }

  console.log();
  console.log(`Success! Created ${manifest.name} at ${root}`);

  helpCommands(manifest, runtime);
}

async function helpCommands(manifest, { packageManager: displayedCommand }) {
  if (!manifest.isUi()) {
    return;
  }

  const useYarn = displayedCommand === 'yarn';

  console.log('Inside that directory, you can run several commands:');
  console.log();
  console.log(chalk.cyan(`  ${displayedCommand} start`));
  console.log('    Starts the development server.');
  console.log();
  console.log(chalk.cyan(`  ${displayedCommand} ${useYarn ? '' : 'run '}build`));
  console.log('    Bundles the app into static files for production.');
  console.log();
  console.log(chalk.cyan(`  ${displayedCommand} ${useYarn ? '' : 'run '}zip`));
  console.log('    Bundles the app into ZIP file in app root directory');
  console.log();
  console.log(chalk.cyan(`  ${displayedCommand} ${useYarn ? '' : 'run '}release`));
  console.log('    Uploads the app ZIP to Corva');
  console.log();
}

initialChecks();
