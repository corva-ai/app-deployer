import chalk from 'chalk';
import figlet from 'figlet';
import { Command, CommanderError, Option } from 'commander';
import fs from 'fs-extra';
import inquirer from 'inquirer';
import os from 'node:os';
import path, { resolve } from 'node:path';
import semver from 'semver';

import { ensureLatestVersion, warnIfOutdated, ensureBumpVersion } from './scripts/utils/version.js';
import * as utils from './helpers/utils.js';
import * as manifestHelpers from './helpers/manifest.js';
import * as versioning from './helpers/versioning.js';

import { getDefaultsForPackageJson } from './constants/package.js';
import * as manifestConstants from './constants/manifest.js';

import packageJson from '../package.json' assert { type: 'json' };
import { clear } from 'node:console';
import spawn from 'cross-spawn';
import { runFlow } from './flow.js';
import { ERROR_ICON } from './constants/messages.js';
import { StepError } from './flows/lib/step-error.js';
import { RELEASE_FLOW } from './flows/release.js';
import { RERUN_FLOW } from './flows/rerun.js';
import { ATTACH_FLOW } from './flows/attach.js';
import { ZIP_FLOW } from './flows/zip.js';
import {
  bumpVersionOption,
  apiKeyOption,
  envOption,
  silentOption,
  appVersion,
  originalCwdOption,
} from './bump-version.option.js';
import { Manifest } from './flows/lib/manifest.js';
import { IS_WINDOWS, resolveAppRuntime } from './helpers/resolve-app-runtime.js';
import { existsSync } from 'node:fs';
import { fileURLToPath } from 'node:url';
import { logger } from './helpers/logger.js';
import _ from 'lodash/fp.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const writejsonOptions = {
  spaces: 2,
  EOL: os.EOL,
};

const silencer =
  (handler) =>
  async (...args) => {
    const result = await handler(...args);

    if (args[args.length - 2].silent && result) {
      console.log(result);
    }
  };

  const getRealWorkingDir = (relativePath, options) => resolve(options.originalCwd, relativePath)

function startingMessage() {
  clear();
  console.log(chalk.green('   Welcome to apps generator for:'));
  console.log(chalk.cyan(figlet.textSync('CORVA.AI', { horizontalLayout: 'full' })));
}

function checkNodeVersion() {
  logger.write('Checking node version...');

  const unsupportedNodeVersion = !semver.satisfies(process.version, '>=16');
  if (unsupportedNodeVersion) {
    logger.log(
      chalk.red(
        `\nYou are using Node ${process.version}.\n\n` +
          `Please update to Node 16 or higher for a better, fully supported experience.\n`
      )
    );
    // Fall back to latest supported react-scripts on Node 4
    return process.exit(1);
  }
  logger.write('  ✅  \n');
}

function checkOptions(opts) {
  let isValid = true;
  const values = {};

  manifestConstants.getManifestMandatoryKeys(opts).forEach((key) => {
    if (!opts[key]) {
      isValid = false;
    }

    values[key] = opts[key];
  });

  return {
    isValid,
    values,
  };
}

const printDeprecationNotice = (param) =>
  console.warn(
    chalk.bgYellowBright`DEPRECATED OPTION: ${param}` +
      ` Use ${chalk.cyan(`create-corva-app ${param} .`)} instead`
  );

export async function run() {
  const program = new Command('create-corva-app')
    .hook('preAction', async () => {
      checkNodeVersion();

      await warnIfOutdated();
    })
    .configureOutput({ writeErr: () => undefined })
    .exitOverride();

  const createCommand = program
    .command('create', { isDefault: true })
    .description('Create a new app')
    .argument('[project-directory]', 'project directory to work with', process.argv[process.argv.length - 1])
    .addOption(originalCwdOption)
    .usage(`${chalk.green('<project-directory>')} [options]`);

  manifestConstants.manifestOptions().forEach((value) => {
    const type = typeof value.default;
    const option = new Option(
      `${value.alias ? `-${value.alias}, ` : ''}--${value.name} [${
        (type !== 'undefined' && type) || 'string'
      }]`,
      value.message,
    );

    if (value.choices) {
      if (typeof value.choices === 'function') {
        option.choices(value.choices());
      } else {
        option.choices(
          value.choices.map((choice) => `${typeof choice === 'object' ? choice.value : choice}`)
        );
      }
    }

    if (type === 'number') {
      option.argParser(Number);
    }

    if (type !== 'undefined') {
      option.default(value.default);
    }

    createCommand.addOption(option);
  });

  createCommand.version(packageJson.version);

  createCommand.action(async (dirName, options) => {
    if (options.zip || options.release) {
      options.bumpVersion = await ensureBumpVersion(options.bumpVersion);
    }

    startingMessage();

    // NOTE: Default action
    await createApp(dirName, options);
  });

  program
    .command('zip')
    .description('Bundle app')
    .argument('<project-directory>', 'Project directory to work with')
    .argument('[patterns...]', 'Additional patterns to zip', [])
    .addOption(bumpVersionOption)
    .addOption(new Option('--ignored-files [ignoredFiles...]', 'Patterns to skip zip', []))
    .addOption(originalCwdOption)
    .addOption(silentOption)
    .action(
      silencer(async (dirName, patterns, options) => {
        options.bumpVersion = await ensureBumpVersion(options.bumpVersion);

        console.log(getRealWorkingDir(dirName, options), options)

        return runFlow(ZIP_FLOW, { dirName: getRealWorkingDir(dirName, options), patterns, options }).then(_.get('zipFileName'));
      })
    );

  program
    .command('release')
    .description('Release app')
    .argument('<project-directory>', 'Project directory to work with')
    .argument('[patterns...]', 'Additional patterns to zip', [])
    .addOption(bumpVersionOption)
    .addOption(new Option('--ignored-files [string...]', 'Patterns to skip zip').default([]))
    .addOption(silentOption)
    .addOption(envOption)
    .addOption(apiKeyOption)
    .addOption(originalCwdOption)
    .addOption(new Option('--notes [string]', 'Add custom notes to published app'))
    .addOption(
      new Option('--label [string]', 'Put a label on the release').choices(['BETA', 'PROD'])
    )
    .addOption(
      new Option(
        '--remove-on-fail [boolean]',
        'Remove release if it fails during deployment'
      ).default(false)
    )
    .addOption(
      new Option(
        '--remove-on-success [boolean]',
        'App package (.zip) will not be deleted after upload'
      ).default(true)
    )
    // .addOption(new Option('--zip-file-name [string]', 'Prebuilt zip file name in dir'))
    .action(async (dirName, patterns, options) => {
      options.bumpVersion = await ensureBumpVersion(options.bumpVersion);

      await runFlow(RELEASE_FLOW, { dirName: getRealWorkingDir(dirName, options), patterns, options });
    });

  program
    .command('rerun')
    .description('Rerun app')
    .argument('<project-directory>', 'Project directory to work with')
    .addOption(apiKeyOption)
    .addOption(envOption)
    .addOption(silentOption)
    .addOption(appVersion)
    .addOption(new Option('--assets [assets...]', 'Assets ids list', []))
    .addOption(new Option('--interval [number]', 'Interval for scheduler apps (exp. 1200)'))
    .addOption(originalCwdOption)
    .action(async (dirName, options) => {
      await runFlow(RERUN_FLOW, { dirName: getRealWorkingDir(dirName, options), options });
    });

  program
    .command('attach')
    .description('Add app to live assets streams')
    .argument('<project-directory>', 'Project directory to work with')
    .addOption(apiKeyOption)
    .addOption(envOption)
    .addOption(silentOption)
    .addOption(appVersion)
    .addOption(originalCwdOption)
    .action(async (dirName, options) => {
      await runFlow(ATTACH_FLOW, { dirName: getRealWorkingDir(dirName, options), options });
    });

  try {
    await program.parseAsync(process.argv);
  } catch (e) {
    handleError(e);

    process.exit(1);
  }
}

const handleError = (e) => {
  if (e instanceof CommanderError) {
    handleCommanderError(e);

    return;
  }

  logger.write(ERROR_ICON);

  if (!(e instanceof StepError)) {
    console.error(chalk.red(e));

    return;
  }

  console.log(chalk.red(e.message));
  e.cause && console.error(chalk.red(e.cause));
};

const handleCommanderError = (e) => {
  switch (e.code) {
    case 'commander.missingArgument': {
      const match = /error:.*'(.*)'/.exec(e.message);

      if (match && match[1] === 'project-directory') {
        const commandName = program.args[0] || program._defaultCommandName;

        console.error('Please specify the project directory:');
        logger.log(
          `  ${chalk.cyan(program.name())} ${commandName} ${chalk.green('<project-directory>')}`
        );
        logger.log();
        logger.log('For example:');
        logger.log(`  ${chalk.cyan(program.name())} ${commandName} ${chalk.green('my-react-app')}`);
        logger.log();
        logger.log(
          `Run ${chalk.cyan(`${program.name()} help ${commandName}`)} to see all options.`
        );
      } else {
        console.error('❌', e.message);
      }

      break;
    }
    case 'commander.help':
    case 'commander.helpDisplayed': {
      // ignore
      break;
    }
    default: {
      console.error('❌', e.message);
    }
  }
};

/**
 *
 * @param {import('./flows/lib/manifest').Manifest} manifest
 */
const getEnvManagementLink = (manifest) => {
  if (manifest.isJs()) {
    if (IS_WINDOWS) {
      return 'https://github.com/coreybutler/nvm-windows';
    }

    return 'https://github.com/nvm-sh/nvm';
  }

  if (IS_WINDOWS) {
    return 'https://github.com/pyenv-win/pyenv-win';
  }

  return 'https://github.com/pyenv/pyenv';
};

async function initPackage(projectName, opts) {
  const manifest = new Manifest(manifestHelpers.fillManifest(opts));
  const runtime = resolveAppRuntime(opts);

  if (!(await runtime.isRuntimeAvailable())) {
    throw new Error(
      `Runtime "${opts.runtime}" is not available locally. Please proceed to ${chalk.green(
        getEnvManagementLink(manifest)
      )} to install it locally.`
    );
  }

  if (manifest.isUi()) {
    await ensureLatestVersion();
  }

  const root = getRealWorkingDir(projectName, opts);

  logger.log(`Creating a new Corva app in ${chalk.green(root)}.`);

  if (fs.existsSync(root)) {
    throw new Error(`Directory already exists: ${root}`);
  }
  await fs.mkdir(root);
  await fs.writeJSON(path.join(root, 'manifest.json'), manifest.manifest, writejsonOptions);

  await addTemplate(root, manifest, runtime);
  await configureApp(root, manifest, runtime);
  await installApp(root, manifest, runtime);

  logger.log();
}

async function createApp(dirName, opts) {
  const { isValid, values } = checkOptions(opts);

  if (isValid) {
    Object.keys(values).forEach((key) => {
      logger.log(`${key} : ${values[key]}`);
    });

    return initPackage(dirName, opts);
  }

  console.log('Please fill your app Metadata');

  const answers = await inquirer.prompt(manifestConstants.manifestOptions(dirName), opts);

  return initPackage(dirName, answers);
}

/**
 *
 * @param {string} root
 * @param {import('./flows/lib/manifest').Manifest} manifest
 * @param {*} runtime
 */
async function addTemplate(root, manifest, runtime) {
  logger.log(chalk.green('Copying app template...'));
  logger.log();

  const templateFolder = path.resolve(
    __dirname,
    '..',
    'templates',
    runtime.language,
    manifest.type
  );

  utils.copyFolderRecursiveSync(templateFolder, root);

  if (manifest.isNode()) {
    utils.copyFolderRecursiveSync(path.resolve(__dirname, '..', 'common', 'node'), root);
  }

  if (manifest.isPython()) {
    utils.copyFolderRecursiveSync(path.resolve(__dirname, '..', 'common', 'python'), root);
  }

  if (!manifest.isUi()) {
    await utils.putVariablesInEnvFile(root, manifest);
  }

  // We can't have .gitignore file in our templates.
  // It's missing when @corva/create-app is installed.
  // That's why we manually rename gitignore to .gitignore after copying template
  fs.renameSync(path.join(root, 'gitignore'), path.join(root, '.gitignore'));

  logger.log(chalk.green('Done: copying app template!'));
}

/**
 *
 * @param {string} root
 * @param {import('./flows/lib/manifest').Manifest} manifest
 * @param {*} runtime
 */
async function configureApp(root, manifest, runtime) {
  if (manifest.isJs()) {
    await addNvmRc(root, manifest, runtime);
    await addPackageJSON(root, manifest, runtime);
  }

  if (manifest.isNode()) {
    await addTsConfigs(root, manifest, runtime);
  }

  if (manifest.isPython() && manifest.isScheduler()) {
    patchSchedulerForPython(root, manifest, runtime);
  }
}

const addNvmRc = async (root, manifest, runtime) => {
  await fs.outputFile(path.join(root, '.nvmrc'), `${runtime.version}\n`);
};

const addTsConfigs = (root, manifest, runtime) => {
  if (runtime.language !== 'typescript') {
    return;
  }

  return Promise.all([
    fs.writeJson(
      path.resolve(root, 'tsconfig.json'),
      {
        extends: `@tsconfig/node${runtime.version}/tsconfig.json`,
        compilerOptions: {
          inlineSourceMap: true,
        },
      },
      writejsonOptions
    ),
    fs.writeJson(
      path.resolve(root, 'tsconfig.build.json'),
      {
        extends: './tsconfig.json',
        include: ['lib/**/*.ts', 'index.ts'],
        exclude: ['node_modules', '**/*.spec.ts'],
      },
      writejsonOptions
    ),
  ]);
};

function patchSchedulerForPython(root, manifest, runtime) {
  const schedulerType = manifest.manifest.settings.app.scheduler_type;

  if (schedulerType === manifestConstants.SCHEDULER_TYPE_DATA_TIME.value) {
    return;
  }

  const templateFolder = path.resolve(
    __dirname,
    '..',
    'templates',
    runtime.language,
    manifest.type
  );
  const originalType = 'ScheduledDataTimeEvent';
  const replacementType =
    schedulerType === manifestConstants.SCHEDULER_TYPE_DEPTH.value
      ? 'ScheduledDepthEvent'
      : 'ScheduledNaturalTimeEvent';
  const patchedCode = fs
    .readFileSync(path.join(templateFolder, 'lambda_function.py'), 'utf-8')
    .replace(new RegExp(originalType, 'g'), replacementType);

  fs.writeFileSync(path.join(root, 'lambda_function.py'), patchedCode);
}

/**
 *
 * @param {string} root
 * @param {import('./flows/lib/manifest').Manifest} manifest
 */
function addPackageJSON(root, manifest, runtime) {
  const defaults = getDefaultsForPackageJson(manifest, runtime);

  const packageJson = {
    name: manifest.unix_name,
    version: defaults.version,
    description: manifest.description || defaults.description,
    engines: {
      node: `^${runtime.version}`,
      [runtime.packageManager]: '*',
    },
    scripts: defaults.scripts,
    dependencies: defaults.dependencies,
    devDependencies: defaults.devDependencies,
    ...(defaults.jest && { jest: defaults.jest }),
  };

  return fs.writeJSON(path.join(root, 'package.json'), packageJson, writejsonOptions);
}

/**
 *
 * @param {string} root
 * @param {import('./flows/lib/manifest').Manifest} manifest
 */
async function installApp(root, manifest, runtime) {
  const command = manifest.isJs() ? runtime.packageManager : 'make';

  if (!IS_WINDOWS || manifest.isJs()) {
    const args = ['install'];
    const opts = { stdio: ['inherit', 'inherit', 'pipe'], cwd: root };

    if (process.env.CI && command === 'yarn') {
      args.push('--cache-folder=".yarn-cache"');
    }

    logger.log(chalk.yellow(`Installing template dependencies using ${runtime.packageManager}...`));
    const proc =
      manifest.isJs() && existsSync(`${os.homedir()}/.nvm/nvm.sh`)
        ? spawn.sync(`\\. ${os.homedir()}/.nvm/nvm.sh && nvm i && ${command} ${args.join(' ')}`, {
            shell: true,
            ...opts,
          })
        : spawn.sync(command, args, opts);

    if (proc.stderr) {
      const error = proc.stderr
        .toString('utf8')
        .split('\n')
        // NOTE: filter out warnings caused by @corva/ui peer dependencies
        .filter((line) => !line.includes('@corva/ui'))
        .join('\n');
      console.log(error);
    }

    if (proc.status !== 0) {
      console.error(`\`${command} ${args.join(' ')}\` failed`);
      return;
    }

    logger.log(chalk.green('Successfull project install'));
  } else {
    logger.log();
    logger.log(`⚠️ ${chalk.yellow('Please install project dependencies manually')}`);
  }

  if (versioning.tryGitInit(root)) {
    logger.log();
    logger.log('Initialized a git repository.');

    if (versioning.tryGitCommit(root)) {
      logger.log();
      logger.log('Created git commit.');
    }
  }

  logger.log();
  logger.log(`Success! Created ${chalk.green(manifest.name)} at ${chalk.yellow(root)}`);

  helpCommands(manifest, runtime);
}

async function helpCommands(manifest, { packageManager: displayedCommand }) {
  if (!manifest.isUi()) {
    return;
  }

  const useYarn = displayedCommand === 'yarn';

  logger.log('Inside that directory, you can run several commands:');
  logger.log();
  logger.log(chalk.cyan(`  ${displayedCommand} start`));
  logger.log('    Starts the development server.');
  logger.log();
  logger.log(chalk.cyan(`  ${displayedCommand} ${useYarn ? '' : 'run '}build`));
  logger.log('    Bundles the app into static files for production.');
  logger.log();
  logger.log(chalk.cyan(`  ${displayedCommand} ${useYarn ? '' : 'run '}zip`));
  logger.log('    Bundles the app into ZIP file in app root directory');
  logger.log();
  logger.log(chalk.cyan(`  ${displayedCommand} ${useYarn ? '' : 'run '}release`));
  logger.log('    Uploads the app ZIP to Corva');
  logger.log();
}
